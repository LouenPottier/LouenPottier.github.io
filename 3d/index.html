<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>3D Portrait</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #0a0a0a;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    padding: 1.5rem 1rem;
    min-height: 100vh;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    color: #eee;
    /* Évite le scroll horizontal sur mobile */
    overflow-x: hidden;
  }

  h1 {
    font-size: 0.9rem;
    font-weight: 300;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: #888;
    margin-bottom: 1.2rem;
  }

  /* Le container s'adapte à la largeur de l'écran sur mobile */
  #container {
    position: relative;
    width: min(85vw, 360px);
    height: min(85vw, 360px);
    border-radius: 50%;
    overflow: hidden;
    box-shadow: 0 0 60px rgba(255,255,255,0.05), 0 0 0 1px #222;
    cursor: grab;
  }
  #container:active { cursor: grabbing; }
  canvas { display: block; width: 100%; height: 100%; }

  #loading {
    position: absolute; inset: 0;
    display: flex; align-items: center; justify-content: center;
    color: #444; font-size: 0.8rem; letter-spacing: 0.1em;
    pointer-events: none;
  }

  /* Bouton de bascule */
  #toggle-btn {
    margin-top: 1.2rem;
    background: none;
    border: 1px solid #333;
    border-radius: 20px;
    color: #888;
    font-size: 0.72rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    padding: 0.45rem 1.2rem;
    cursor: pointer;
    transition: border-color 0.2s, color 0.2s;
    min-width: 160px;
  }
  #toggle-btn:hover { border-color: #666; color: #ccc; }
  #toggle-btn:active { border-color: #aaa; color: #fff; }

  /* Sliders — largeur = même que le container */
  #controls {
    margin-top: 1rem;
    display: flex; flex-direction: column; gap: 0.6rem;
    width: min(85vw, 360px);
  }
  .ctrl-row { display: flex; align-items: center; gap: 0.8rem; }
  .ctrl-row label {
    width: 110px; text-align: right;
    font-size: 0.68rem; color: #555; letter-spacing: 0.07em; flex-shrink: 0;
  }
  input[type=range] {
    -webkit-appearance: none; flex: 1; height: 2px;
    background: #2a2a2a; border-radius: 2px; outline: none;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px; height: 18px;   /* plus grand sur mobile pour le touch */
    border-radius: 50%; background: #fff; cursor: pointer;
  }
</style>
</head>
<body>

<h1>3D Portrait</h1>

<div id="container">
  <canvas id="canvas"></canvas>
  <div id="loading">chargement…</div>
</div>

<button id="toggle-btn">⬡ Points</button>

<div id="controls">
  <div class="ctrl-row">
    <label>GAUCHE / DROITE</label>
    <input type="range" id="sliderY" min="-60" max="60" value="0" step="0.5">
  </div>
  <div class="ctrl-row">
    <label>HAUT / BAS</label>
    <input type="range" id="sliderX" min="-45" max="45" value="0" step="0.5">
  </div>
  <div class="ctrl-row">
    <label>DISTANCE</label>
    <input type="range" id="sliderZ" min="0.3" max="3.0" value="1.0" step="0.05">
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ─── Config ───────────────────────────────────────────────────────────────────
const SPLAT_URL = "./nation.splat";
const OBJ_URL   = "./nation.obj";

// ─── Renderer ─────────────────────────────────────────────────────────────────
const canvas    = document.getElementById("canvas");
const container = document.getElementById("container");

// Taille réelle du container (responsive)
function getSize() { return container.getBoundingClientRect().width; }

const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setClearColor(0x0a0a0a, 1);

function resizeRenderer() {
  const s = getSize();
  renderer.setSize(s, s, false);   // false = ne pas toucher le style CSS
}
resizeRenderer();
window.addEventListener("resize", resizeRenderer);

const scene  = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, 1, 0.001, 100);

// ─── État ─────────────────────────────────────────────────────────────────────
let rotY = 0, rotX = 0, autoRot = true, pivot = null;
let camDistBase = 3.0, camDistMult = 1.0;
let mode = "mesh";   // "mesh" | "splat"
let meshObj  = null;   // THREE.Mesh mis en cache après premier chargement
let splatData = null;  // données parsées .splat mises en cache

const MAX_Y = Math.PI / 3;
const MAX_X = Math.PI / 4;

// ─── Sliders ──────────────────────────────────────────────────────────────────
const sliderY = document.getElementById("sliderY");
const sliderX = document.getElementById("sliderX");
const sliderZ = document.getElementById("sliderZ");

sliderY.addEventListener("input", () => { autoRot = false; rotY = +sliderY.value * Math.PI / 180; });
sliderX.addEventListener("input", () => { autoRot = false; rotX = +sliderX.value * Math.PI / 180; });
sliderZ.addEventListener("input", () => {
  camDistMult = +sliderZ.value;
  camera.position.z = camDistBase * camDistMult;
  camera.updateProjectionMatrix();
});

// ─── Drag souris ──────────────────────────────────────────────────────────────
let dragging = false, lastMX = 0, lastMY = 0;
container.addEventListener("mousedown", e => { dragging = true; lastMX = e.clientX; lastMY = e.clientY; autoRot = false; });
window.addEventListener("mouseup", () => { dragging = false; });
window.addEventListener("mousemove", e => {
  if (!dragging || !pivot) return;
  rotY = Math.max(-MAX_Y, Math.min(MAX_Y, rotY + (e.clientX - lastMX) * 0.008));
  rotX = Math.max(-MAX_X, Math.min(MAX_X, rotX + (e.clientY - lastMY) * 0.008));
  sliderY.value = (rotY * 180 / Math.PI).toFixed(1);
  sliderX.value = (rotX * 180 / Math.PI).toFixed(1);
  lastMX = e.clientX; lastMY = e.clientY;
});

// ─── Touch ────────────────────────────────────────────────────────────────────
let lastTX = 0, lastTY = 0;
container.addEventListener("touchstart", e => {
  lastTX = e.touches[0].clientX; lastTY = e.touches[0].clientY; autoRot = false;
}, { passive: true });
container.addEventListener("touchmove", e => {
  if (!pivot) return;
  rotY = Math.max(-MAX_Y, Math.min(MAX_Y, rotY + (e.touches[0].clientX - lastTX) * 0.008));
  rotX = Math.max(-MAX_X, Math.min(MAX_X, rotX + (e.touches[0].clientY - lastTY) * 0.008));
  sliderY.value = (rotY * 180 / Math.PI).toFixed(1);
  sliderX.value = (rotX * 180 / Math.PI).toFixed(1);
  lastTX = e.touches[0].clientX; lastTY = e.touches[0].clientY;
}, { passive: true });

// ─── Utilitaire : centrer une géométrie sur la surface du visage ──────────────
function centerGeometry(positions, n, isFlat) {
  // positions : Float32Array ou BufferAttribute selon le mode
  const getX = isFlat ? i => positions[i*3]   : i => positions.getX(i);
  const getY = isFlat ? i => positions[i*3+1] : i => positions.getY(i);
  const getZ = isFlat ? i => positions[i*3+2] : i => positions.getZ(i);

  let sumX = 0, sumY = 0;
  const zArr = [];
  for (let i = 0; i < n; i++) { sumX += getX(i); sumY += getY(i); zArr.push(getZ(i)); }
  const cx = sumX / n, cy = sumY / n;
  zArr.sort((a, b) => a - b);
  const cz = zArr[Math.floor(n * 0.4)];

  if (isFlat) {
    for (let i = 0; i < n; i++) {
      positions[i*3]   -= cx;
      positions[i*3+1] -= cy;
      positions[i*3+2] -= cz;
    }
  } else {
    for (let i = 0; i < n; i++) {
      positions.setXYZ(i, getX(i) - cx, getY(i) - cy, getZ(i) - cz);
    }
    positions.needsUpdate = true;
  }
  return { cx, cy, cz };
}

// ─── Construction scène générique ─────────────────────────────────────────────
function mountObject(obj3d, geo) {
  while (scene.children.length) scene.remove(scene.children[0]);

  geo.computeBoundingBox();
  const size = new THREE.Vector3();
  geo.boundingBox.getSize(size);
  const maxDim = Math.max(size.x, size.y, size.z);

  pivot = new THREE.Object3D();
  pivot.add(obj3d);
  scene.add(pivot);

  camDistBase = maxDim * 1.8;
  camera.position.set(0, 0, camDistBase * camDistMult);
  camera.near = maxDim * 0.001;
  camera.far  = maxDim * 20;
  camera.lookAt(0, 0, 0);
  camera.updateProjectionMatrix();

  document.getElementById("loading").style.display = "none";
  autoRot = true; rotY = 0; rotX = 0;
  sliderY.value = sliderX.value = 0;
}

// ─── Mode SPLAT ───────────────────────────────────────────────────────────────
function parseSplat(buffer) {
  const BYTES = 32, n = Math.floor(buffer.byteLength / BYTES);
  const view = new DataView(buffer);
  const positions = new Float32Array(n * 3);
  const colors    = new Float32Array(n * 3);
  for (let i = 0; i < n; i++) {
    const b = i * BYTES;
    positions[i*3+0] = view.getFloat32(b +  0, true);
    positions[i*3+1] = view.getFloat32(b +  4, true);
    positions[i*3+2] = view.getFloat32(b +  8, true);
    colors[i*3+0]    = view.getUint8(b + 24) / 255;
    colors[i*3+1]    = view.getUint8(b + 25) / 255;
    colors[i*3+2]    = view.getUint8(b + 26) / 255;
  }
  return { positions, colors, n };
}

function buildSplat(data) {
  centerGeometry(data.positions, data.n, true);

  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.BufferAttribute(data.positions, 3));
  geo.setAttribute("color",    new THREE.BufferAttribute(data.colors,    3));

  const ptSize = Math.max(2.5, Math.min(5.0, 600 / Math.sqrt(data.n)));
  const mat = new THREE.PointsMaterial({ size: ptSize, vertexColors: true, sizeAttenuation: false });

  mountObject(new THREE.Points(geo, mat), geo);
}

// ─── Mode MESH ────────────────────────────────────────────────────────────────
async function loadOBJ(url) {
  const text = await fetch(url).then(r => {
    if (!r.ok) throw new Error(`HTTP ${r.status} — ${url}`);
    return r.text();
  });

  const lines = text.split('\n');
  const verts = [], uvs = [], faces = [];
  let mtlFile = null, texFile = null;

  for (const raw of lines) {
    const line = raw.trim();
    if (!line || line.startsWith('#')) continue;
    const parts = line.split(/\s+/);
    if      (parts[0] === 'mtllib') mtlFile = parts[1];
    else if (parts[0] === 'v')      verts.push([+parts[1], +parts[2], +parts[3]]);
    else if (parts[0] === 'vt')     uvs.push([+parts[1], +parts[2]]);
    else if (parts[0] === 'f') {
      faces.push(parts.slice(1).map(tok => {
        const [vi, ti] = tok.split('/').map(Number);
        return { vi: vi - 1, ti: ti - 1 };
      }));
    }
  }

  if (mtlFile) {
    const base = url.substring(0, url.lastIndexOf('/') + 1);
    const mtlText = await fetch(base + mtlFile).then(r => r.text()).catch(() => '');
    for (const line of mtlText.split('\n')) {
      const p = line.trim().split(/\s+/);
      if (p[0] === 'map_Kd') texFile = base + p[1];
    }
  }

  const posArr = [], uvArr = [];
  for (const face of faces)
    for (const { vi, ti } of face) { posArr.push(...verts[vi]); uvArr.push(...uvs[ti]); }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(posArr, 3));
  geo.setAttribute('uv',       new THREE.Float32BufferAttribute(uvArr,  2));

  let mat;
  if (texFile) {
    const tex = await new Promise((resolve, reject) =>
      new THREE.TextureLoader().load(texFile, resolve, undefined, reject)
    );
    tex.flipY = true;
    mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.FrontSide });
  } else {
    mat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
  }

  return new THREE.Mesh(geo, mat);
}

function buildMesh(mesh) {
  const pos = mesh.geometry.attributes.position;
  centerGeometry(pos, pos.count, false);
  mesh.geometry.computeVertexNormals();
  mountObject(mesh, mesh.geometry);
}

// ─── Chargement initial (mesh par défaut) ─────────────────────────────────────
function showLoading() {
  const el = document.getElementById("loading");
  el.textContent = "chargement…";
  el.style.display = "flex";
}

async function init() {
  showLoading();
  try {
    meshObj = await loadOBJ(OBJ_URL);
    buildMesh(meshObj);
    updateToggleBtn();
  } catch(err) {
    document.getElementById("loading").textContent = "erreur : " + err.message;
    console.error(err);
  }
}
init();

// ─── Bouton de bascule ────────────────────────────────────────────────────────
function updateToggleBtn() {
  const btn = document.getElementById("toggle-btn");
  btn.textContent = mode === "mesh" ? "⬡ Points" : "▦ Mesh";
}

document.getElementById("toggle-btn").addEventListener("click", async () => {
  mode = mode === "mesh" ? "splat" : "mesh";
  updateToggleBtn();
  showLoading();

  try {
    if (mode === "splat") {
      if (!splatData) {
        const buf = await fetch(SPLAT_URL).then(r => {
          if (!r.ok) throw new Error(`HTTP ${r.status}`);
          return r.arrayBuffer();
        });
        splatData = parseSplat(buf);
      }
      // Recréer les positions car buildSplat les modifie in-place
      const buf = await fetch(SPLAT_URL).then(r => r.arrayBuffer());
      buildSplat(parseSplat(buf));
    } else {
      // Recharger le mesh (les positions ont été modifiées in-place aussi)
      meshObj = await loadOBJ(OBJ_URL);
      buildMesh(meshObj);
    }
  } catch(err) {
    document.getElementById("loading").textContent = "erreur : " + err.message;
    console.error(err);
  }
});

// ─── Rendu ────────────────────────────────────────────────────────────────────
function animate() {
  requestAnimationFrame(animate);
  if (pivot) {
    if (autoRot) {
      rotY = Math.sin(Date.now() * 0.0004) * (Math.PI / 6);
      sliderY.value = (rotY * 180 / Math.PI).toFixed(1);
    }
    pivot.rotation.order = "YXZ";
    pivot.rotation.y = rotY;
    pivot.rotation.x = rotX;
  }
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
